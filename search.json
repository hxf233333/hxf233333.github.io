[{"title":"MySQL学习笔记_day10(完结)","url":"https://hxf233333.gitee.io/2021/03/06/MySQL学习笔记_day10(完结)/","content":"12 流程控制结构\n顺序机构：程序从上往下一次\n分支结构：程序从两条或者多条路径中选择一条去执行\n循环结构：程序在满足一定的基础上，重复执行一段代码\n\n12.1 分支结构12.1.1 IF函数\n功能：实现简单的双分支\n\n语法：\n\n\nIF（表达式1，表达式2，表达式3）\n\n执行顺序：如果表达式1成立，则IF函数返回表达式2的值，否则返回表达式3的值\n\n应用：任何地方\n\n12.1.2 CASE结构\n情况1：类似于c++的switch语句，一般用于实现等值判断\n\n\n语法：\nCASE 变量|表达式|字段\n\tWHEN 要判断的值 THEN 返回的值1或语句1;\n\tWHEN 要判断的值 THEN 返回的值2或语句2;\n\t...\n\tELSE 要返回的值n或语句n;\nEND CASE;\n\n\n\n\n情况2：类似于c++中的多重IF语句，一般用于实现区间判断\n\n\n语法：\nCASE \n\tWHEN 要判断的条件1 THEN 返回的值1或语句1;\n\tWHEN 要判断的条件2 THEN 返回的值2或语句2;\n\t...\n\tELSE 要返回的值n或语句n;\nEND CASE;\n\n\n特点：\n\n\n①可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，BEGIN END 中或BEGIN END的外面，可以作为独立的语句去使用，只能放在BEGIN END中\n②如果WHEN中的值满足或条件成立，则执行对应的THEN后面的语句，并且结束CASE，如果都不满足，则执行ELSE中的语句或值\n③ELSE可以省略，如果省略了，并且所有WHEN条件都不满足，则返回NULL\n\n#案例\n#创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：90-100，显示A；80-90，显示B；60-80，显示C；否则，显示D\nCREATE PROCEDURE test_case(IN scare INT)\nBEGIN\n\tCASE \n\tWHEN scare>=90 AND scare&lt;=100 THEN SELECT 'A';\n\tWHEN scare>=80 THEN SELECT 'B';\n\tWHEN scare>=60 THEN SELECT 'C';\n\tELSE SELECT 'D';\n\tEND CASE;\nEND $\n\nCALL test_case(95)$\n12.1.3 IF结构\n功能：实现多重分支\n\n语法：\n\n\nIF 条件1 THEN 语句1；\nELSEIF 条件2 THEN 语句2；\n...\n[ELSE 语句n;]\nEND IF;\n\n应用场合：应用在BEGIN END中\n\n#案例：创建函数，根据传入的成绩，来返回等级，比如传入的成绩：90-100，返回A；80-90，返回B；60-80，返回C；否则，返回D\nCREATE FUNCTION test_if(score INT) RETURN CHAR\nBEGIN\n\tIF score>=90 AND score&lt;=100 THEN RETURN 'A';\n\tELSEIF score>=80 THEN RETURN 'B';\n\tELSEIF scare>=60 THEN RETURN 'C';\n\tELSE RETURN 'D';\n\tEND IF;\nEND $\n\nCALL test_if(86)$\n12.2 循环结构\n分类：\n\nwhile、loop、repeat\n\n循环控制：\n\n\niterate 类似于continue，继续，结束本次循环，继续下一次leave 类似于 break，跳出，结束当前所在的循环\n\n\n使用范围：begin end中\n\n12.2.1 while\n语法：\n\n[标签:]while 循环条件 do\n      循环体;\nend while [标签];\n\n特点：先判断后执行\n\n1.没有添加控制条件\n#1.没有添加控制条件\n#案例：批量插入，根据次数插入到admin表中多条记录\nCREATE PROCEDURE pro_while(IN insertCount INT)\nBEGIN\n\tDECLARE i INT DEFAULT 1;\n\tWHILE i&lt;=insertCount DO\n\t\tINSERT INTO admin(username,'password') VALUES(CONCAT('Rose',i),'666');\n\t\tSET i=i+1;\n\tEND WHILE;\nEND $\n\nCALL pro_while1(100)$\n\n2.添加leave语句\n#案例：批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止\nTRUNCATE TABLE admin$\nDROP PROCEDURE test_while1$\nCREATE PROCEDURE test_while1(IN insertCount INT)\nBEGIN\n\tDECLARE i INT DEFAULT 1;\n\ta:WHILE i&lt;=insertCount DO\n\t\tINSERT INTO admin(username,'password') VALUES(CONCAT('xiaohua',1),'0000');\n\t\tIF i>=20 THEN LEAVE a;\n\t\tEND IF;\n\t\tSET i=i+1;\n\tEND WHILE a;\nEND $\n\nCALL test_while(100)$\n3.添加iterate语句\n#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次\nTRUNCATE TABLE admin$\nDROP PROCEDURE test_while1$\nCREATE PROCEDURE test_while1(IN insertCount INT)\nBEGIN\n\tDECLARE i INT DEFAULT 1;\n\ta:WHILE i&lt;=insertCount DO\n\t\tSET i=i+1;\n\t\tIF MOD(i,2)!=0 THEN ITERATE a;\n\t\tEND IF;\n\t\tINSERT INTO admin(username,'password') VALUES(CONCAT('xiaohua',1),'0000');\n\tEND WHILE a;\nEND $\n\nCALL test_while(100)$\n12.2.2 loop\n语法：\n\n[标签:]loop\n循环体;\nend loop [标签];\n\n特点：可以用来模拟简单的死循环\n\n12.2.3 repeat语法：\n[标签:] repeat\n\t循环体;\nuntil 结束循环的条件\nend repeat [标签];\n\n特点：先执行后判断\n\n","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day9","url":"https://hxf233333.gitee.io/2021/03/05/MySQL学习笔记_day9/","content":"10 变量\n系统变量：全局变量、会话变量\n自定义变量：用户变量、局部变量\n\n10.1 系统变量\n说明：变量由系统提供，不是用户定义，属于服务器层面\n\n1、查看所有的系统变量\nSHOW GLOBAL | [SESSION] VARIABLES;\n\n2、查看所有满足条件的部分系统变量\nSHOW GLOBAL | [SESSION] VARIABLES LIKE '%char%';\n\n3、查看指定的某个系统变量的值\nSELECT @@global | [SESSION] .系统变量名;\n\n4、为某个系统变量赋值\n方式一：\nSET GLOBAL | [SESSION] 系统变量名 = 值;\n\n方式二：\nSET @@global | [SESSION] .系统变量名 = 值;\n\n注意：如果是全局级别，则需要加GLOBAL，如果是会话级别，则需要加SESSION，如果不写，则默认sesion \n10.2 自定义变量\n说明：变量是用户自定义的，不是由系统的\n使用步骤：声明、赋值、使用（查看，比较，运算等）\n\n10.2.1 用户变量\n作用域：针对于当前会话（连续）有效，同于会话变量的作用域；应用在任何地方，也就是BEGIN END里面或者外面\n\n赋值的操作符： =或:=\n\n\n\n①声明并初始化\nSET @用户变量名=值；或\nSET @用户变量名:=值；或\nSELECT @用户变量名:=值;\n\n②赋值（更新用户变量的值）方式一；通过SET或SELECT\nSET @用户变量名=值;或\nSET @用户变量名:=值;或\nSELECT @用户变量名:=值;\n\n方式二：通过SELECT INTO\nSELECT 字段 INTO 变量名 FROM 表;\n\n③使用（查看用户变量的值）\nSELECT @用户变量名;\n\n10.2.2 局部变量\n作用域：仅仅在定义它的BEGIN END中有效\n\n\n①声明\nDECLARE 变量名 类型;\nDECLARE 变量名 类型 DEFAULT 值;\n\n②赋值方式一；通过SET或SELECT\nSET 局部变量名=值;或\nSET 局部变量名:=值;或\nSELECT @局部变量名:=值;\n\n方式二：通过SELECT INTO\nSELECT 字段 INTO 局部变量名 FROM 表;\n\n③使用\nSELECT 局部变量名;\n\n11 存储过程和函数\n存储过程和函数：类似于面向对象中的方法\n\n好处：\n\n\n\n1、提高代码的重用性\n2、简化操作\n\n11.1 存储过程\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n\n\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n11.1.1 创建语法\nCREATE PROCEDURE 存储过程名（参数列表）\nBEGIN\n存储过程体（一组合法的SQL语句）\nEND\n注意：\n\n\n1、参数列表包含三部分\n参数模式 参数名 参数类型\n举例：\nIN stuname VARCHAR(20)\n\n参数模式：\nIN：该参数可以作为输入，也就是改参数需要方传入值\nOUT：该参数可以作为输出，也就是该参数可以作为返回值\nINOUT：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值\n\n2、如果存储过程体仅仅只有一句话，BEGIN END 可以省略\n存储过程体中的每条SQL语句的结尾要求必须加分号。\n存储过程的结尾可以使用DELIMITER重新设置\n语法：\nDELIMITER 结束标记\n案例：\nDELIMITER $\n\n11.1.2 调用语法#1、空参列表\n#案例：插入到admin表中3条记录\n\nSELECT * FROM admin;\n\nDELIMITER $\nCREATE PROCEDURE myp1()\nBEGIN\n\tINSERT INTO amdin(username,'password')\n\tVALUES('john','00000'),('lily','00000')('jack','00000');\t\nEND $\n#调用\nCALL myp1()$\n\n#2、创建带in模式参数的存储过程\n#案列1：创建存储过程实现根据女生名，查询对应的男神信息\nCREATE PROCEDURE myp2(IN beautyName VARCHAR(20))\nBEGIN\n\tSELECT bo.* \n\tFROM boys bo\n\tRIGHT JOIN beauty b ON bo.id = b.boyfriend_id\n\tWHERE b.name = beautyName;\nEND $\n#调用\nCALL myp2('张飞')$\n\n#3、创建带out模式的存储过程\n#案例：根据女神名，返回对应的男神名\nCREATE PROCEDURE myp5(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))\nBEGIN\n\tSELECT bo.boyName INTO boyName\n\tFROM boys bo\n\tINNER JOIN beauty b ON bo.id = b.boyfriend_id\n\tWHERE b.name = beautyName;\nEND $\n#调用\nCALL myp5('小昭'，@bname)$\nSELECT @bname$\n\n#4、创建带inout模式的存储过程\n#案例：传入a和b两个值，最终a和b都翻倍并返回\nCREATE PROCEDURE myp6(INOUT a INT,INOUT b INT)\nBEGIN\n\tSET a=a*2;\n\tSET b=b*2;\nEND\n#调用\nSET @m=10$\nSET @n=20$\nCALL myp6(@m,@n)$\nSELECT @m,@n$\n11.1.3 删除存储过程语法： DROP PROCEDURE 存储过程名\nDROP PROCEDURE p1;\nDROP PROCEDURE p2,p3;\n11.1.4 查看存储过程的信息DESC myp2;\nSHOW CREATE PROCEDURE myp2;\n11.2 函数\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n\n\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n\n区别：\n\n\n存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新\n函数：有且仅有有个返回，适合做处理数据后返回一个结果\n\n11.2.1 创建语法CREATE FUNCTION 函数名（参数列表） RETURNS 返回类型\nBEGIN\n\t函数体\nEND\n\n注意：\n\n\n1、参数列表 包含两部分：参数名 参数类型\n2、函数体：肯定会有RETURN语句，如果没有会报错如果RETURN语句没有放在函数体的最后也不会报错，但不建议\n3、函数体中仅有一句话，则可以省略BEGIN END\n4、使用DELIMITER语句设置结束标记\n\n11.2.2 调用语法SELECT 函数名（参数列表）\n#-------------案列演示-----------------\n#1、无参数返回\n#案例：返回公司的员工个数\nCREATE FUNCTION myf1() RETURNS INT\nBEGIN\n\tDECLARE c INT DEFAULT 0;#定义变量\n\tSELECT COUNT(*) INTO c#赋值\n\tFROM employees;\n\tRETURN c;\nEND $\n\nSELECT myf1()$\n\n#2、有参数返回\n#案例：根据部门名，返回该部门的平均工资\nCREATE FUNCTION myf2(deptName VARCHAR(20)) RETURNS DOUBLE\nBEGIN\n\tDECLARE sal DOUBLE;\n\tSELECT AVG(salary) INTO sal\n\tFROM employees e\n\tJOIN department d ON e.department_id = d.department_id\n\tWHERE d.department_name=deptName;\n\tRETURN sal;\nEND $\nSELECT myf2('IT')$\n11.2.3 查看函数SHOW CREATE FUNCTION myf2;\n11.2.4 删除函数DROP FUNCTION myf2;\n#案例：创建函数，实现传入两个float，返回二者之和\nCREATE FUNCTION test_fun1(num1 FLOAT,nums FLOAT) RETURN FLOAT\nBEGIN\n\tDECLARE SUM FLOAT DEFAULT 0;\n\tSET SUM = num1+nums;\n\tRETURN SUM;\nEND $\nSELECT test_funs(1,2)$\n","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day8","url":"https://hxf233333.gitee.io/2021/03/03/MySQL学习笔记_day8/","content":"7.4 标识列\n含义：又称为自增长列，可以不用手动的插入值，系统提供默认的序列值\n\n特点：\n\n\n\n1、自增长列要求必须设置在一个键上，比如主键或唯一键2、自增长列要求数据类型为数值型3、一个表至多有一个自增长列\n\nCREATE TABLE gradeinfo(\n\tgradeID INT PRIMARY KEY AUTO_INCREMENT,\n\tgradeName VARCHAR(20)\n);\n\nSELECT * FROM gradeinfo;\n\nINSERT INTO gradeinfo VALUES(NULL,'一年级'),(NULL,'2年级'),(NULL,'3年级');\n\nINSERT INTO gradeinfo(gradename)VALUES('一年级'),('2年级'),('3年级');\n\n\n8 TCL 语言\nTranscaction Control Language：事务控制语言\n\n概念：由一条或多条sql语句组成，要么都成功，要么都失败\n\n特性：ACID\n\n\n\n原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。\n一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。\n隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。\n持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。\n\n\n分类：\n\n\n隐式事务：没有明显的开启和结束标记    比如DML语句的insert、update、delete语句本身就是一条事务\ninsert into stuinfo values(1,'john','男','ert@dd.com',12);\n\n\n\n显式事务：具有明显的开启和结束标记\n一般由多条SQL语句组成，必须具有明显的开启和结束标记\n步骤：\n\t取消隐式事务自动开启的功能\n\t1、开启事务\n\t2、编写事务需要的sql语句（1条或多条）\n\tinsert into stuinfovalues(1,'john','男','ert@dd.com',12);\n\tinsert into stuinfo values(1,'john','男','ert@dd.com',12);\n\t3、结束事务\n\n\nsavepoint 节点名;设置保存点\n\n事务的隔离级别:\n\n\n\n\n\n事务的隔离级别\n脏读\n不可重复读\n幻读\n\n\n\nread uncommitted\n√\n√\n√\n\n\nread committed\n×\n√\n√\n\n\nrepeatable read\n×\n×\n√\n\n\nserializable\n×\n×\n×\n\n\n\n1.MySQL中默认第三个隔离级别 repeatable read\n2.Oracle中默认第二个隔离级别 read commited\n3.查看隔离级别\nselect @@tx_isolation;\n\n4.设置隔离级别\nset session|global trancate isolation level 隔离级别;\n  #演示事务的使用步骤\n\nSHOW VARIABLES LIKE '%auto%'\n\n#1、取消事务自动开启\nSET autocommit=0;\n\n#2、开启事务\nSTART TRANSACTION;\n\n#3、编写事务的sql语句\n\n#将张三丰的钱-5000\nUPDATE stuinfo SET balance=balance-5000 WHERE stuid = 1;\n\n#将灭绝的钱+5000\nUPDATE stuinfo SET balance=balance+5000 WHERE stuid = 2;\n\n#4、结束事务\n#回滚\nROLLBACK;\n#提交\nCOMMIT;\n\nSELECT * FROM stuinfo;\n#演示事务对于delete和truncate的处理的区别DELETE 支持回滚，TRUNCATE不支持回滚\nSET autocommit=0;\nSTART TRANSACTION;\nDELETE FROM stuinfo;\nROLLBACK;\n#演示savepoint的使用\nSET autocommit=0;\nSTART TRANSACTION;\nDELETE FROM stuinfo WHERE id = 1;\nSAVEPOINT a; #设置保存点\nDELETE FROM stuinfo WHERE id = 2;\nROLLBACK TO a; #回滚到保存点\nSELECT * FROM stuinfo;\n9 视图\n含义：虚拟表，和普通表一样使用，是通过表动态生成的数据\n\n创建表与视图的区别\n\n\n\n\n\n类型\n创建语法的关键字\n是否实际占用物理空间\n使用\n\n\n\n视图\ncreate view\n只是保存了sql逻辑\n一般不能增删改\n\n\n表\ncreate table\n保存了数据\n增删改查\n\n\n#一、创建视图\n语法：\nCREATE VIEW 视图\nAS\n查询语句;\n\nUSE myemployees;\n#1.查询姓名中包含a字符的员工名、部门信息和工种信息\n#①创建\nCREATE VIEW myv1\nAS\nSELECT last_name,department_name,job_title\nFROM employees e\nJOIN departments d ON e.department_id = d.department_id\nJOIN jobs j ON j.job_id = e.job_id;\n \n#②使用\nSELECT * FROM myv1 WHERE last_name LIKE '%a%';\n\n#二、视图的修改\n#方式一：\nCREATE OR REPLACE VIEW 视图名\nAS\n查询语句;\n\n#方式二：\nALTER VIEW 视图名\nAS\n查询语句;\n\n\n#三、删除视图\n语法：\nDROP VIEW 视图名,视图名,...;\n\n#四、查看视图\nDESC myv3;\nSHOW CREATE VIEW myv3;\n\n#五、视图的更新\nCREATE OR REPLACE VIEW myv1\nAS\nSELECT last_name,email\nFROM employees;\n\nSELECT * FROM myv1;\n\n#1.插入\nINSERT INTO myv1 VALUES('张飞'，'zf@qq.com');\n\n#2.修改\nUPDATE myv1 SET last_name = '张无忌' WHERE last_name = '张飞';\n\n#3.删除\nDELETE FROM myv1 WHERE last_name = '张无忌';\n\n具备以下特点的视图不允许更新\n\n\n①包含以下关键字的sql语句：分组函数、distinct、group by、hanving、union或者union all②常量视图③select中包含子查询④含有join⑤from一个不能更新的视图⑥where子句的子查询引用了from子句中的表\n\n","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day7","url":"https://hxf233333.gitee.io/2021/03/02/MySQL学习笔记_day7/","content":"7 DDL语言\nData Define Language数据定义语言 ：用于对数据库和表的管理和操作\n\n7.1 库和表的管理\n1.库的管理创建、修改、删除2、表弟管理创建、修改、删除\n创建：create修改：alter删除：drop\n\n7.1.1 库的管理#---------------------------库的管理------------------------√\n\n#一、创建数据库\nCREATE DATABASE stuDB;\nCREATE DATABASE IF NOT EXISTS stuDB;\n\n#二、库的修改\nRENAME DATABASE books TO 新库名;\nALTER DATABASE books CHARACTER SET gbk; #更改库的字符集\n\n#三、删除数据库\nDROP DATABASE stuDB;\nDROP DATABASE IF EXISTS stuDB;\n\n7.1.2 表的管理一、创建表 ★\n语法：\nCREATE TABLE [IF NOT EXISTS] 表名(\n\t字段名  字段类型  【字段约束】,\n\t字段名  字段类型  【字段约束】,\n\t字段名  字段类型  【字段约束】,\n\t字段名  字段类型  【字段约束】,\n\t字段名  字段类型  【字段约束】\n);\n\n案例：没有添加约束\nCREATE TABLE IF NOT EXISTS stuinfo(\n\tstuid INT ,\n\tstuname VARCHAR(20),\n\tstugender CHAR(1),\n\temail VARCHAR(20),\n\tborndate DATETIME\n);\n\n案例：添加约束（通用写法）\nDROP TABLE IF EXISTS stuinfo;\nCREATE TABLE IF NOT EXISTS stuinfo(\n\tstuid INT PRIMARY KEY,#添加了主键约束\n\tstuname VARCHAR(20) UNIQUE NOT NULL,#添加了唯一约束+非空\n\tstugender CHAR(1) DEFAULT '男',#添加了默认约束\n\temail VARCHAR(20) NOT NULL,\n\tage INT CHECK( age BETWEEN 0 AND 100),#添加了检查约束，mysql不支持\n\tmajorid INT,\n\tCONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major(id)#添加了外键约束\n);\n二、修改表[了解]\n语法：ALTER TABLE 表名 ADD|MODIFY|CHANGE|DROP COLUMN 字段名 字段类型 【字段约束】;\n\n#1.修改表名\nALTER TABLE stuinfo RENAME TO students;\n\n#2.添加字段\nALTER TABLE students ADD COLUMN borndate TIMESTAMP NOT NULL;\nDESC students;\n\n#3.修改字段名\nALTER TABLE students CHANGE COLUMN borndate birthday DATETIME NULL;\n\n#4.修改字段类型\nALTER TABLE  students MODIFY COLUMN birthday TIMESTAMP ;\n\n#5.删除字段\nALTER TABLE students DROP COLUMN birthday;\nDESC students;\n三、删除表 √\nDROP TABLE IF EXISTS students;\n四、复制表√\n#仅仅复制表的结构\nCREATE TABLE newTable2 LIKE major;\n\n#复制表的结构+数据\nCREATE TABLE newTable3 SELECT * FROM girls.`beauty`;\n\n#案例：复制employees表中的last_name,department_id,salary字段到新表 emp表，但不复制数据\nCREATE TABLE emp \nSELECT last_name,department_id,salary \nFROM myemployees.`employees`\nWHERE 1=2;\n7.2 数据类型1、整型\nTINYINT SMALLINT  INT  BIGINT \n\n2、浮点型\nFLOAT(m,n)\nDOUBLE(m,n) \nDECIMAL(m,n)\nm:整数部位长度+小数部位长度\nn:小数部位长度\nm和n可选\n\n3、字符型\nCHAR(n):n可选\nVARCHAR(n)：n必选 \nTEXT \nENUM\nSET\nn表示最多字符个数\n\n4、日期型\nDATE TIME  DATETIME TIMESTAMP\n\n5、二进制型\nBLOB 存储图片数据\n7.3 常见约束\n说明：用于限制表中字段的数据的，从而进一步保证数据表的数据是一致的、准确的、可靠的！\n\nNOT NULL 非空：用于限制该字段为必填项\nDEFAULT 默认：用于限制该字段没有显式插入值，则直接显式默认值\nPRIMARY KEY 主键：用于限制该字段值不能重复，设置为主键列的字段默认不能为空\n\t一个表只能有一个主键，当然可以是组合主键\nUNIQUE 唯一：用于限制该字段值不能重复\n\t\t字段是否可以为空   一个表可以有几个\n\t\t\n\t主键\t   ×\t\t\t\t1个\n\t唯一     √\t\t\t\tn个\nCHECK检查：用于限制该字段值必须满足指定条件\n\tCHECK(age BETWEEN 1 AND 100)\nFOREIGN KEY 外键:用于限制两个表的关系,要求外键列的值必须来自于主表的关联列\n\t要求：\n\t①主表的关联列和从表的关联列的类型必须一致，意思一样，名称无要求\n\t②主表的关联列要求必须是主键\n\t③插入数据时，先插入主表，再插入从表\n\t④删除数据时，先删除从表，再删除主表\n","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day6","url":"https://hxf233333.gitee.io/2021/03/01/MySQL学习笔记_day6/","content":"6 DML语言\nDML(Data Manipulation Language) 数据操纵语言：insert update delete\n作用：对表中的数据的增删改\n\n6.1 数据的插入\n语法：\n\n插入单行：\n\tinsert into 表名(字段名1,字段名2 ,...) values (值1，值2,...); #支持子查询\n\tinsert into 表名 set 列名=值,列名=值,...;  #不支持子查询\n插入多行：\n\tinsert into 表名(字段名1,字段名2 ,...) values\n\t (值1，值2,...),(值1，值2,...),(值1，值2,...);\n\n特点：\n\n\n①字段和值列表一一对应包含类型、约束等必须匹配\n②数值型的值，不用单引号非数值型的值，必须使用单引号\n③字段顺序无要求\n\nSELECT * FROM stuinfo;\n#案例1：要求字段和值列表一一对应，且遵循类型和约束的限制\nINSERT INTO stuinfo(stuid,stuname,stugender,email,age,majorid)\nVALUES(1,'吴倩','男','wuqian@qq.com',12,1); \n\nINSERT INTO stuinfo(stuid,stuname,stugender,email,age,majorid)\nVALUES(6,'李宗盛2','女','wuqian@qq.com',45,2); \n\n#案例2：可以为空字段如何插入\n#方案1：字段名和值都不写\nINSERT INTO stuinfo(stuid,stuname,email,majorid)\nVALUES(5,'齐鱼','qiqin@qq.com',2); \n\n#方案1：字段名写上，值使用null\nINSERT INTO stuinfo(stuid,stuname,email,age,majorid)\nVALUES(5,'齐鱼','qiqin@qq.com',NULL,2); \nSELECT * FROM stuinfo;\n\n#案例3：默认字段如何插入\n#方案1：字段名写上，值使用default\nINSERT INTO stuinfo(stuid,stuname,email,stugender,majorid)\nVALUES(7,'齐小鱼','qiqin@qq.com',DEFAULT,2); \n\n#方案2：字段名和值都不写\nINSERT INTO stuinfo(stuid,stuname,email,majorid)\nVALUES(7,'齐小鱼','qiqin@qq.com',2); \n\n#案例4：可以省略字段列表，默认所有字段\nINSERT INTO stuinfo VALUES(8,'林忆莲','女','lin@126.com',12,3);\nINSERT INTO stuinfo VALUES(NULL,'小黄','男','dd@12.com',12,3);\nSELECT * FROM stuinfo;\n6.2 数据的修改\n语法：\n\nupdate 表名 set 字段名 = 新值,字段名 = 新值,...\nwhere 筛选条件;\n#案例1：修改年龄&lt;20的专业编号为3号，且邮箱更改为 xx@qq.com\nUPDATE stuinfo SET majorid = 3,email='xx@qq.com'\nWHERE age&lt;20;\n6.3 数据的删除\n语法：\n\n方式1：delete语句\n\t语法：delete from 表名 where 筛选条件;\n方式2：truncate语句\n\t语法：truncate table 表名;\n#案例1：删除姓李所有信息\nDELETE FROM stuinfo WHERE stuname LIKE '李%';\n\n#案例2：删除表中所有数据\nTRUNCATE TABLE stuinfo ;\n\n【面试题】delete和truncate的区别\n\n1.delete可以添加WHERE条件\n  TRUNCATE不能添加WHERE条件，一次性清除所有数据\n\n2.truncate的效率较高\n\n3.如果删除带自增长列的表，\n  使用DELETE删除后，重新插入数据，记录从断点处开始\n  使用TRUNCATE删除后，重新插入数据，记录从1开始\n  SELECT * FROM gradeinfo;\n  TRUNCATE TABLE gradeinfo;\n  INSERT INTO gradeinfo(gradename)VALUES('一年级'),('2年级'),('3年级');\n  \n4.delete 删除数据，会返回受影响的行数\n  TRUNCATE删除数据，不返回受影响的行数\n  \n5.delete删除数据，可以支持事务回滚\n  TRUNCATE删除数据，不支持事务回滚\n","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day5","url":"https://hxf233333.gitee.io/2021/02/28/MySQL学习笔记_day5/","content":"5.7 子查询\n说明：\n当一个查询语句中又嵌套了另一个完整的select语句，则被嵌套的select语句称为子查询或内查询，外面的select语句称为主查询或外查询。\n\n分类：\n按子查询出现的位置进行分类：\n\n\n\n1、select后面    要求：子查询的结果为单行单列（标量子查询）2、from后面    要求：子查询的结果可以为多行多列3、where或having后面 ★    要求：子查询的结果必须为单列        单行子查询        多行子查询4、exists后面    要求：子查询结果必须为单列（相关子查询）\n\n\n特点：\n\n1、子查询放在条件中，要求必须放在条件的右侧2、子查询一般放在小括号中3、子查询的执行优先于主查询4、单行子查询对应了 单行操作符：&gt; &lt; &gt;= &lt;= = &lt;&gt;5、多行子查询对应了 多行操作符：any/some  all in \n\n#一、放在where或having后面\n#一）单行子查询\n\n#案例1：谁的工资比 Abel 高?\n#①查询Abel的工资\nSELECT salary\nFROM employees\nWHERE last_name  = 'Abel';\n#②查询salary>①的员工信息\nSELECT last_name,salary\nFROM employees\nWHERE salary>(\n\tSELECT salary\n\tFROM employees\n\tWHERE last_name = 'Abel'\n);\n\n#案例2：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id 和工资\n#①查询141号员工的job_id\nSELECT job_id\nFROM employees\nWHERE employee_id = 141\n\n#②查询143号员工的salary\nSELECT salary\nFROM employees\nWHERE employee_id = 143\n\n#③查询job_id=① and salary>②的信息\nSELECT last_name,job_id,salary\nFROM employees\nWHERE job_id = (\n\tSELECT job_id\n\tFROM employees\n\tWHERE employee_id = 141\n) AND salary>(\n\n\tSELECT salary\n\tFROM employees\n\tWHERE employee_id = 143\n\n);\n\n\n#案例3：返回公司工资最少的员工的last_name,job_id和salary\n#①查询最低工资\nSELECT MIN(salary)\nFROM employees\n#②查询salary=①的员工的last_name,job_id和salary\nSELECT last_name,job_id,salary\nFROM employees\nWHERE salary=(\n\tSELECT MIN(salary)\n\tFROM employees\n\n);\n\n#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资\n#①查询50号部门的最低工资\nSELECT MIN(salary)\nFROM employees\nWHERE department_id = 50;\n\n#②查询各部门的最低工资，筛选看哪个部门的最低工资>①\nSELECT MIN(salary),department_id\nFROM employees\nGROUP BY department_id\nHAVING MIN(salary)>(\n\n\tSELECT MIN(salary)\n\tFROM employees\n\tWHERE department_id = 50\n);\n\n\n#二）多行子查询\n/*\n\nin:判断某字段是否在指定列表内  \nx in(10,30,50)\n\nany/some:判断某字段的值是否满足其中任意一个\n\nx>any(10,30,50)\nx>min()\n\nx=any(10,30,50)\nx in(10,30,50)\n\nall:判断某字段的值是否满足里面所有的\n\nx >all(10,30,50)\nx >max()\n\n*/\n\n\n#案例1：返回location_id是1400或1700的部门中的所有员工姓名\n#①查询location_id是1400或1700的部门\nSELECT department_id\nFROM departments\nWHERE location_id IN(1400,1700)\n\n#②查询department_id = ①的姓名\nSELECT last_name\nFROM employees\nWHERE department_id IN(\n\tSELECT DISTINCT department_id\n\tFROM departments\n\tWHERE location_id IN(1400,1700)\n\n);\n\n\n#题目：返回其它部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary\n#①查询job_id为‘IT_PROG’部门的工资\nSELECT DISTINCT salary\nFROM employees\nWHERE job_id = 'IT_PROG'\n\n#②查询其他部门的工资&lt;任意一个①的结果\nSELECT employee_id,last_name,job_id,salary\nFROM employees\nWHERE salary&lt;ANY(\n\tSELECT DISTINCT salary\n\tFROM employees\n\tWHERE job_id = 'IT_PROG'\n);\n\n等价于\n\nSELECT employee_id,last_name,job_id,salary\nFROM employees\nWHERE salary&lt;(\n\tSELECT MAX(salary)\n\tFROM employees\n\tWHERE job_id = 'IT_PROG'\n);\n\n#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工 的员工号、姓名、job_id 以及salary\n#①查询job_id为‘IT_PROG’部门的工资\nSELECT DISTINCT salary\nFROM employees\nWHERE job_id = 'IT_PROG'\n\n#②查询其他部门的工资&lt;所有①的结果\nSELECT employee_id,last_name,job_id,salary\nFROM employees\nWHERE salary&lt;ALL(\n\tSELECT DISTINCT salary\n\tFROM employees\n\tWHERE job_id = 'IT_PROG'\n);\n\n等价于\n\nSELECT employee_id,last_name,job_id,salary\nFROM employees\nWHERE salary&lt;(\n\tSELECT MIN(salary)\n\tFROM employees\n\tWHERE job_id = 'IT_PROG'\n);\n\n\n#二、放在select后面\n#案例；查询部门编号是50的员工个数\nSELECT \n(\n\tSELECT COUNT(*)\n\tFROM employees\n\tWHERE department_id = 50\n)   个数;\n\n\n#三、放在from后面\n\n#案例：查询每个部门的平均工资的工资级别\n#①查询每个部门的平均工资\nSELECT AVG(salary),department_id\nFROM employees\nGROUP BY department_id\n\n#②将①和sal_grade两表连接查询\nSELECT dep_ag.department_id,dep_ag.ag,g.grade\nFROM sal_grade g\nJOIN (\n\tSELECT AVG(salary) ag,department_id\n\tFROM employees\n\tGROUP BY department_id\n) dep_ag ON dep_ag.ag BETWEEN g.min_salary AND g.max_salary;\n\n\n#四、放在exists后面\n#案例1 ：查询有无名字叫“张三丰”的员工信息\nSELECT EXISTS(\n\tSELECT * \n\tFROM employees\n\tWHERE last_name = 'Abel'\n\n) 有无Abel;\n\n\n#案例2：查询没有女朋友的男神信息\nUSE girls;\nSELECT bo.*\nFROM boys bo\nWHERE bo.`id` NOT IN(\n\tSELECT boyfriend_id\n\tFROM beauty b\n)\n\nSELECT bo.*\nFROM boys bo\nWHERE NOT EXISTS(\n\tSELECT boyfriend_id\n\tFROM beauty b\n\tWHERE bo.id = b.boyfriend_id\n);\n5.8 分页查询\n应用场景：当页面上的数据，一页显示不全，则需要分页显示\n\n分页查询的sql命令请求数据库服务器——&gt;服务器响应查询到的多条数据——&gt;前台页面\n\n语法：\n\nselect 查询列表\nfrom 表1 别名\njoin 表2 别名\non 连接条件\nwhere 筛选条件\ngroup by 分组\nhaving 分组后筛选\norder by 排序列表\nlimit 起始条目索引,显示的条目数\n\n执行顺序：\n\n1、from子句\n2、join子句\n3、on子句\n4、where子句\n5、group by子句\n6、having子句\n7、select子句\n8、order by子句\n9、limit子句\n\n特点：\n\n①起始条目索引如果不写，默认是0②limit后面支持两个参数参数1：显示的起始条目索引参数2：条目数\n\n\n公式：\n\n假如要显示的页数是page，每页显示的条目数为size\n\nselect *\nfrom employees\nlimit (page-1)*size,size;\n\npage\t\tsize=10\n1           limit 0,10\n2\t\t\tlimit 10,10\n3\t\t\tlimit 20,10\n4\t\t\tlimit 30,10\n5.9 联合查询\n说明：\n当查询结果来自于多张表，但多张表之间没有关联，这个时候往往使用联合查询，也称为union查询\n\n\n\n语法：\n\nselect 查询列表 from 表1  where 筛选条件  \nunion\nselect 查询列表 from 表2  where 筛选条件  \n\n特点：1、多条待联合的查询语句的查询列数必须一致，查询类型、字段意义最好一致2、union实现去重查询;union all 实现全部查询，包含重复项\n\n#案例：查询所有国家的年龄>20岁的用户信息\nSELECT * FROM usa WHERE uage >20 UNION\nSELECT * FROM chinese WHERE age >20 ;\n\n#案例2：查询所有国家的用户姓名和年龄\nSELECT uname,uage FROM usa\nUNION\nSELECT age,`name` FROM chinese;\n\n#案例3：union自动去重/union all 可以支持重复项\nSELECT 1,'范冰冰' \nUNION ALL\nSELECT 1,'范冰冰' \nUNION  ALL\nSELECT 1,'范冰冰' \nUNION  ALL\nSELECT 1,'范冰冰' ;\n","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day4","url":"https://hxf233333.gitee.io/2021/02/27/MySQL学习笔记_day4/","content":"5.5 分组查询\n语法：\n\nselect 查询列表\nfrom 表名\nwhere 筛选条件\ngroup by 分组列表\nhaving 分组后筛选\norder by 排序列表;\n\n执行顺序：\n\n①from子句②where子句③group by 子句④having子句⑤select子句⑥order by子句\n\n\n特点：\n①查询列表往往是分组函数和被分组的字段 ★\n②分组查询中的筛选分为两类\n\n\n\n\n\n\n筛选的基表\n使用的关键词\n位置\n\n\n\n分组前筛选\n原始表\nwhere\ngroup by 的前面\n\n\n组后筛选\n分组后的结果集\nhaving\ngroup by的后面\n\n\nwhere——group by ——having\n\n问题：==分组函数做条件只可能放在having后面==！！！\n\n#1）简单的分组\n#案例1：查询每个工种的员工平均工资\nSELECT AVG(salary),job_id\nFROM employees\nGROUP BY job_id;\n\n#案例2：查询每个领导的手下人数\nSELECT COUNT(*),manager_id\nFROM employees\nWHERE manager_id IS NOT NULL\nGROUP BY manager_id;\n\n#2）可以实现分组前的筛选\n#案例1：查询邮箱中包含a字符的 每个部门的最高工资\nSELECT MAX(salary) 最高工资,department_id\nFROM employees\nWHERE email LIKE '%a%'\nGROUP BY department_id;\n\n#案例2：查询每个领导手下有奖金的员工的平均工资\nSELECT AVG(salary) 平均工资,manager_id\nFROM employees\nWHERE commission_pct IS NOT NULL\nGROUP BY manager_id;\n\n#3）可以实现分组后的筛选\n#案例1：查询哪个部门的员工个数>5\n#分析1：查询每个部门的员工个数\nSELECT COUNT(*) 员工个数,department_id\nFROM employees\nGROUP BY department_id\n\n#分析2：在刚才的结果基础上，筛选哪个部门的员工个数>5\nSELECT COUNT(*) 员工个数,department_id\nFROM employees\n\nGROUP BY department_id\nHAVING  COUNT(*)>5;\n\n\n#案例2：每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT job_id,MAX(salary)\nFROM employees\nWHERE commission_pct  IS NOT NULL\nGROUP BY job_id\nHAVING MAX(salary)>12000;\n\n#案例3：领导编号>102的    每个领导手下的最低工资大于5000的最低工资\n#分析1：查询每个领导手下员工的最低工资\nSELECT MIN(salary) 最低工资,manager_id\nFROM employees\nGROUP BY manager_id;\n\n#分析2：筛选刚才1的结果\nSELECT MIN(salary) 最低工资,manager_id\nFROM employees\nWHERE manager_id>102 \nGROUP BY manager_id\nHAVING MIN(salary)>5000 ;\n\n\n#4）可以实现排序\n#案例：查询没有奖金的员工的最高工资>6000的工种编号和最高工资,按最高工资升序\n#分析1：按工种分组，查询每个工种有奖金的员工的最高工资\nSELECT MAX(salary) 最高工资,job_id\nFROM employees\nWHERE commission_pct IS  NULL\nGROUP BY job_id\n\n#分析2：筛选刚才的结果，看哪个最高工资>6000\nSELECT MAX(salary) 最高工资,job_id\nFROM employees\nWHERE commission_pct IS  NULL\nGROUP BY job_id\nHAVING MAX(salary)>6000\n\n#分析3：按最高工资升序\nSELECT MAX(salary) 最高工资,job_id\nFROM employees\nWHERE commission_pct IS  NULL\nGROUP BY job_id\nHAVING MAX(salary)>6000\nORDER BY MAX(salary) ASC;\n\n#5）按多个字段分组\n#案例：查询每个工种每个部门的最低工资,并按最低工资降序\n#提示：工种和部门都一样，才是一组\n\n工种\t部门  工资\n1\t 10\t  10000\n1    20   2000\n2\t 20\n3    20\n1    10\n2    30\n2    20\n\nSELECT MIN(salary) 最低工资,job_id,department_id\nFROM employees\nGROUP BY job_id,department_id;\n5.6 连接查询\n说明：又称多表查询，当查询语句涉及到的字段来自于多个表时，就会用到连接查询\n\n\n笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行\n\n发生原因：没有有效的连接条件如何避免：添加有效的连接条件\n\n\n分类：\n\n按年代分类：\n1、sql92标准:仅仅支持内连接\n内连接：\n\t等值连接\n\t非等值连接\n\t自连接\n\n2、sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n按功能分类：\n\t内连接：\n\t\t等值连接\n\t\t非等值连接\n\t\t自连接\n\t外连接：\n\t\t左外连接\n\t\t右外连接\n\t\t全外连接\n\t交叉连接\n5.6.1 SQL 92标准\n语法:\n\nselect 查询列表\nfrom 表1 别名,表2 别名\nwhere 连接条件\nand 筛选条件\ngroup by 分组列表\nhaving 分组后筛选\norder by 排序列表\n\n执行顺序：\n\n1、from子句\n2、where子句\n3、and子句\n4、group by子句\n5、having子句\n6、select子句\n7、order by子句\n\n\n#---------------------------------sql92标准------------------\n#一、内连接\n\n#一）等值连接\n/*\n①多表等值连接的结果为多表的交集部分\n②n表连接，至少需要n-1个连接条件\n③多表的顺序没有要求\n④一般需要为表起别名\n⑤可以搭配前面介绍的所有子句使用，比如排序、分组、筛选\n*/\n\n#案例1：查询女神名和对应的男神名\nSELECT NAME,boyName \nFROM boys,beauty\nWHERE beauty.boyfriend_id= boys.id;\n\n#案例2：查询员工名和对应的部门名\nSELECT last_name,department_name\nFROM employees,departments\nWHERE employees.`department_id`=departments.`department_id`;\n\n#2、为表起别名\n/*\n①提高语句的简洁度\n②区分多个重名的字段\n\n注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定\n*/\n#查询员工名、工种号、工种名\nSELECT e.last_name,e.job_id,j.job_title\nFROM employees  e,jobs j\nWHERE e.`job_id`=j.`job_id`;\n\n\n#3、两个表的顺序是否可以调换\n\n#查询员工名、工种号、工种名\nSELECT e.last_name,e.job_id,j.job_title\nFROM jobs j,employees e\nWHERE e.`job_id`=j.`job_id`;\n\n\n#4、可以加筛选\n\n#案例：查询有奖金的员工名、部门名\nSELECT last_name,department_name,commission_pct\nFROM employees e,departments d\nWHERE e.`department_id`=d.`department_id`\nAND e.`commission_pct` IS NOT NULL;\n\n#案例2：查询城市名中第二个字符为o的部门名和城市名\nSELECT department_name,city\nFROM departments d,locations l\nWHERE d.`location_id` = l.`location_id`\nAND city LIKE '_o%';\n\n\n#5、可以加分组\n\n#案例1：查询每个城市的部门个数\nSELECT COUNT(*) 个数,city\nFROM departments d,locations l\nWHERE d.`location_id`=l.`location_id`\nGROUP BY city;\n\n#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资\nSELECT department_name,d.`manager_id`,MIN(salary)\nFROM departments d,employees e\nWHERE d.`department_id`=e.`department_id`\nAND commission_pct IS NOT NULL\nGROUP BY department_name,d.`manager_id`;\n\n\n#6、可以加排序\n\n#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序\nSELECT job_title,COUNT(*)\nFROM employees e,jobs j\nWHERE e.`job_id`=j.`job_id`\nGROUP BY job_title\nORDER BY COUNT(*) DESC;\n\n\n#7、可以实现三表连接？\n\n#案例：查询员工名、部门名和所在的城市\nSELECT last_name,department_name,city\nFROM employees e,departments d,locations l\nWHERE e.`department_id`=d.`department_id`\nAND d.`location_id`=l.`location_id`\nAND city LIKE 's%'\n\nORDER BY department_name DESC;\n\n\n\n#二）非等值连接\n\n#案例1：查询员工的工资和工资级别\nSELECT salary,grade_level\nFROM employees e,job_grades g\nWHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`\nAND g.`grade_level`='A';\n\n\n#三）自连接\n\n#案例：查询 员工名和上级的名称\nSELECT e.employee_id,e.last_name,m.employee_id,m.last_name\nFROM employees e,employees m\nWHERE e.`manager_id`=m.`employee_id`;\n\n\n5.6.2 SQL 99标准\n语法：\n\nSELECT 查询列表\nFROM 表名1 别名\n【连接类型】 JOIN  表名2 别名\nON 连接条件\nWHERE 筛选条件\nGROUP BY 分组列表\nHAVING 分组后筛选\nORDER BY 排序列表;\n\n连接类型：\n\n内连接：inner（可省略）外连接 左外：left 【outer】右外：right 【outer】全外：full 【outer】交叉连接： cross\n\n\nSQL 92和SQL 99的区别：\nSQL99，使用JOIN关键字代替了之前的逗号，并且将连接条件和筛选条件进行了分离，提高阅读性！！！\n\n\n#------------------------SQL99语法----------------------\n#一、内连接\n/*\n分类：\n等值连接\n非等值连接\n自连接\n\n特点：\n①添加排序、分组筛选\n②inner可以省略\n③筛选条件放在where后面，连接条件放在on，提高分离性，便于阅读\n④inner join连接和sql92语法中的等值连接效果是一样的。都是查询多表的交集\n*/\n#一）等值连接\n\n#①简单连接\n#案例：查询员工名和部门名\nSELECT last_name,department_name\nFROM departments d \nJOIN employees e \nON e.department_id =d.department_id;\n\n#②添加筛选条件\n#案例1：查询部门编号>100的部门名和所在的城市名\nSELECT department_name,city\nFROM departments d\nJOIN locations l\nON d.`location_id` = l.`location_id`\nWHERE d.`department_id`>100;\n\n#③添加分组+筛选\n#案例1：查询每个城市的部门个数\nSELECT COUNT(*) 部门个数,l.`city`\nFROM departments d\nJOIN locations l\nON d.`location_id`=l.`location_id`\nGROUP BY l.`city`;\n\n#④添加分组+筛选+排序\n#案例1：查询部门中员工个数>10的部门名，并按员工个数降序\nSELECT COUNT(*) 员工个数,d.department_name\nFROM employees e\nJOIN departments d\nON e.`department_id`=d.`department_id`\nGROUP BY d.`department_id`\nHAVING 员工个数>10\nORDER BY 员工个数 DESC;\n\n\n#二）非等值连接\n\n#案例：查询部门编号在10-90之间的员工的工资级别，并按级别进行分组\nSELECT COUNT(*) 个数,grade\nFROM employees e\nJOIN sal_grade g\nON e.`salary` BETWEEN g.`min_salary` AND g.`max_salary`\nWHERE e.`department_id` BETWEEN 10 AND 90\nGROUP BY g.grade;\n\n\n#三）自连接\n\n#案例：查询员工名和对应的领导名\nSELECT e.`last_name`,m.`last_name`\nFROM employees e\nJOIN employees m\nON e.`manager_id`=m.`employee_id`;\n\n\n#二、外连接\n/*\n应用场景：用于查询一个表中，另一个表中没有的记录\n\n特点：\n1、外连接的查询结果为主表的所有记录\n\t如果从表中有和它匹配的，则显示匹配的值\n\t如果从表中没有和它匹配的，则显示为null\n\t外连接查询结果=内连接结果+主表中有而从表没有的记录\n2、左外连接，left join左边的是主表\n   右外连接，right join右边的是主表\n3、左外和右外交换两个表的顺序，可以实现同样的效果\n4、全外连接=内连接的结果+表1中有但表2中没有的+表2中有的但表1中没有的 \n*/\n\n#案例1、查询编号>3 的女神的男朋友信息，如果有则列出详细，如果没有，用 null 填充\nSELECT b.id,b.name,bo.*\nFROM beauty b\nLEFT JOIN boys bo ON b.boyfriend_id = bo.id\nWHERE b.id>3;\n\n#案例2、查询哪个城市没有部门\nSELECT l.city\nFROM departments d\nRIGHT JOIN locations l ON l.location_id = d.location_id\nWHERE d.`department_id` IS NULL;\n","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day3","url":"https://hxf233333.gitee.io/2021/02/26/MySQL学习笔记_day3/","content":"5.4 常见函数\n概念：类似于c++的方法，将一组逻辑语句封装在方法体中，对外暴露方法名\n\n好处：1.隐藏了实现细节 2.提高代码的重用性\n\n调用：select  函数名（实参列表） 【from表】;\n\n特点：\n​    ①叫什么（函数名）\n​    ②干什么（函数功能）\n\n分类：\n​    1、单行函数\n​    如 concat、length、ifnull等    \n​    2、分组函数\n​    功能：做统计使用，又称为统计函数、聚合函数、组函数\n\n\n5.4.1 单行函数#一、字符函数\n\n#1.length 获取参数值的字节个数\nSELECT LENGTH('john');\nSELECT LENGTH('张三丰hahaha'); #utf8:汉字占3个字节\n\nSHOW VARIABLES LIKE '%char%';\n\n#2.concat 拼接字符串\nSELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees;\n\n#3.upper、lower\nSELECT UPPER('john');\nSELECT LOWER('joHn');\n#示例：将姓变大，名变小写，然后拼接\nSELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees;\n\n#4.substr、substring\n/*\n注意：起始索引从1开始！！！\nsubstr(str,起始索引，截取的字符长度)\nsubstr(str,起始索引)\n*/\n#截取从指定索引处后面所有字符\nSELECT SUBSTR('张三丰爱上了郭襄',7) out_put;\n\n#截取从指定索引处指定字符串长度的字符\nSELECT SUBSTR('张三丰爱上了郭襄',1,3) out_put;\n\n#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来\nSELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2)))\nAS out_put\nFROM employees;\n\n#5.instr 返回子串第一次出现的索引，如果找不到返回0\nSELECT INSTR('三打白骨精aaa白骨精bb白骨精','白骨精') out_put;\n\n#6.trim 去前后指定的字符，默认是去空格\nSELECT TRIM(' 虚  竹    ')  AS a;\nSELECT TRIM('x' FROM 'xxxxxx虚xxx竹xxxxxxxxxxxxxxxxxx')  AS a;\n\n#7.lpad/rpad 左填充/右填充\nSELECT LPAD('木婉清',10,'a'); #左填充10个a\nSELECT RPAD('木婉清',10,'a'); #右填充10个a\n\n#8.replace(字符,被替换字符,替换字符) 替换\n\n\n#二、数学函数\n\n#1.abs 绝对值\nSELECT ABS(-2.4);\n\n#2.ceil 向上取整  返回>=该参数的最小整数\nSELECT CEIL(-1.09);\nSELECT CEIL(0.09);\nSELECT CEIL(1.00);\n\n#3.floor 向下取整，返回&lt;=该参数的最大整数\nSELECT FLOOR(-1.09);\nSELECT FLOOR(0.09);\nSELECT FLOOR(1.00);\n\n#4.round 四舍五入\nSELECT ROUND(1.8712345);\nSELECT ROUND(1.8712345,2);\n\n#5.truncate 截断\nSELECT TRUNCATE(1.8712345,1);\n\n#6.mod 取模\nSELECT MOD(-10,3);\n#a%b = a-(INT)a/b*b\n#-10%3 = -10 - (-10)/3*3   = -1\n\n\n#三、日期函数\n\n#1.now 返回当前系统日期+时间\nSELECT NOW();\n\n#2.curdate 返回当前系统日期，不包含时间\nSELECT CURDATE();\n\n#3.curtime 返回当前时间，不包含日期\nSELECT CURTIME();\n\n#4.可以获取指定的部分，年、月、日、时、分、秒\nSELECT YEAR(NOW()) 年；\nSELECT YEAR(hiredate) 年 FROM employees；\n\n#5.str_to_date 按指定格式解析字符串为日期类型\nSELECT * FROM employees\nWHERE hiredate&lt;STR_TO_DATE('3/15 1998','%m/%d %Y');\n\n#6.date_format 将日期转换成字符\nSELECT DATE_FORMAT(NOW(),'%Y年%m月%d日') 日期;\n\n\n#四、其他函数\n\nSELECT VERSION();\nSELECT DATABASE();\nSELECT USER();\n\n\n#五、流程控制函数\n\n#1.if函数\n\nSELECT IF(100>9,'好','坏');\n\n#案例：如果有奖金，则显示最终奖金，如果没有，则显示0\nSELECT IF(commission_pct IS NULL,0,salary*12*commission_pct) 奖金,commission_pct\nFROM employees;\n\n#2.case函数\n①情况1 ：类似于switch语句，可以实现等值判断\nCASE 表达式\nWHEN 值1 THEN 结果1\nWHEN 值2 THEN 结果2\n...\nELSE 结果n\nEND\n\n案例：\n部门编号是30，工资显示为2倍\n部门编号是50，工资显示为3倍\n部门编号是60，工资显示为4倍\n否则不变\n\n显示 部门编号，旧工资，新工资\n\nSELECT department_id,salary,\nCASE department_id\nWHEN 30 THEN salary*2\nWHEN 50 THEN salary*3\nWHEN 60 THEN salary*4\nELSE salary\nEND  newSalary\nFROM employees;\n\n\n②情况2：类似于多重IF语句，实现区间判断\nCASE \nWHEN 条件1 THEN 结果1\nWHEN 条件2 THEN 结果2\n...\n\nELSE 结果n\n\nEND\n\n案例：如果工资>20000,显示级别A\n      工资>15000,显示级别B\n      工资>10000,显示级别C\n      否则，显示D\n      \n SELECT salary,\n CASE \n WHEN salary>20000 THEN 'A'\n WHEN salary>15000 THEN 'B'\n WHEN salary>10000 THEN 'C'\n ELSE 'D'\n END\n AS  a\n FROM employees;   \n\n5.4.2 分组函数\n说明：分组函数往往用于实现将一组数据进行统计计算，最终得到一个值，又称为聚合函数或统计函数\n\n分组函数清单：\n​    sum(字段名)：求和\n​    avg(字段名)：求平均数\n​    max(字段名)：求最大值\n​    min(字段名)：求最小值\n​    count(字段名)：计算非空字段值的个数\n\n特点：\n​    1、sum、avg一般用于处理数值型，max、min、count可以处理任何类型\n​    2、以为分组函数都忽略null值\n​    3、可以和distinct搭配实现去重的运算\n​    4、一般使用count(*)用作统计函数\n​    5、和分组函数一同查询的字段要求是group by后的字段    \n\n\n#案例1 ：查询员工信息表中，所有员工的工资和、工资平均值、最低工资、最高工资、有工资的个数\nSELECT SUM(salary),AVG(salary),MIN(salary),MAX(salary),COUNT(salary) FROM employees;\n\n#案例2：添加筛选条件\n\t#①查询emp表中记录数：\n\tSELECT COUNT(employee_id) FROM employees;\n\n\t#②查询emp表中有佣金的人数：\n\tSELECT COUNT(salary) FROM employees;\n\t\n\t#③查询emp表中月薪大于2500的人数：\n\tSELECT COUNT(salary) FROM employees WHERE salary>2500;\n\n\t#④查询有领导的人数：\n\tSELECT COUNT(manager_id) FROM employees;\n\t\t\n#count的补充介绍★ \n#1、统计结果集的行数，推荐使用count(*)\t\nSELECT COUNT(*) FROM employees;\nSELECT COUNT(*) FROM employees WHERE department_id = 30;\n\nSELECT COUNT(1) FROM employees;\nSELECT COUNT(1) FROM employees WHERE department_id = 30;\n\n#2、搭配distinct实现去重的统计\n#案例：查询有员工的部门个数\nSELECT COUNT(DISTINCT department_id) FROM employees;\n\n#思考：每个部门的总工资、平均工资？\nSELECT SUM(salary)  FROM employees WHERE department_id = 30;\nSELECT SUM(salary)  FROM employees WHERE department_id = 50;\n\nSELECT SUM(salary) ,department_id\nFROM employees\nGROUP BY department_id;\n","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day2","url":"https://hxf233333.gitee.io/2021/02/25/MySQL学习笔记_day2/","content":"5.2 条件查询#进阶2：条件查询\n/* \n语法：\n\tselect \n\t\t查询列表\n\tfrom\n\t\t表名\n\twhere\n\t\t筛选条件\n分类：\n\t一、按条件表达式筛选\n\t\n\t条件运算符：> &lt; = != &lt;> >= &lt;=\n\t\n\t二、按逻辑表达式筛选\n\t\n\t逻辑运算符：\n\t\t&amp;&amp; || ！\n\t\tand or not\n\t三、模糊查询\n\t\tlike\n\t\tbetween and\n\t\tin\n\t\tis null|is not null\n\n*/\n#一、按条件表达式筛选\n#案例1：查询工资>12000的员工信息\nSELECT\n\t*\nFROM\n\temployees\nWHERE\n\tsalary>12000;\n\n#案列2：查询部门编号不等于90号的员工名和部门编号\nSELECT\n\tlast_name,\n\tdepartment_id,\nFROM\n\temployees\nWHERE\n\tdepartment_id&lt;>90;\n\n#二、按逻辑表达式筛选\n#案例1：查询工资在10000到20000之间的员工名、工资以及奖金\nSELECT\n\tlast_name,salary,commission_pct\nFROM\n\temployees\nWHERE\n\tsalary>=10000 AND salary&lt;=20000;\n#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息\nSELECT\n\t*\nFROM\n\temployees\nWHERE\n\tNOT(department_id&lt;90 AND department_id>110) OR salary>15000;\n\n#三、模糊查询\n/* \nlike\nbetween and\nin\nis null|is not null\n\n*/\n#1.like\n/*\n特点：\n①一般和通配符搭配使用\n\t通配符：\n\t% 任意多个字符，包含0个字符\n\t_ 任意单个字符\n*/\n#案例1：查询员工中包含字符a的员工信息\nSELECT\n\t*\nFROM\n\temployees\nWHERE\n\tlast_name LIKE '%a%';  #abc\n#案例2：查询员工名中第三个字符为n，第五个字符为l的员工名和工资\nSELECT\n\tlast_name,salary\nFROM\n\temployees\nWHERE\n\tlast_name LIKE '__n_l%';\n#案例3：查询姓名中包含第二个字符为_的员工信息\nSELECT \n\t*\nFROM \n\temployees\nWHERE \n\tlast_name LIKE '_\\_%'; #转义\\\n#--------------------------------------------\nSELECT \n\t*\nFROM \n\temployees\nWHERE \n\tlast_name LIKE '_$_%' ESCAPE '$'; #自定义转义escape\n\n#2.between and/not between and\n/*\n①使用between and 可以提高语句的\n②包含临界值，不要调换顺序\n*/\n#案例：查询员工编号在100到120之间的员工信息\nSELECT \n\t*\nFROM\n\temployees\nWHERE \n\temployees_id BETWEEN 100 AND 120;\n\n#3.in\n/*\n功能：查询某字段的值是否属于指定的列表之内\n特点：\n\t①使用in提高语句简洁度\n\t②in列表的值类型必须统一\n\n*/\n\n#案例1：查询部门编号是30/50/90的员工名、部门编号\n\nSELECT \n\tlast_name,department_id\nFROM \n\temployees\nWHERE \n\tdepartment_id IN(30,50,90);\n#-----------------------------------\nSELECT \n\tlast_name,department_id\nFROM \n\temployees\nWHERE \n\tdepartment_id=30 OR department_id=50 OR department_id=90;\n\t\n#案例2：查询工种编号不是SH_CLERK或IT_PROG的员工信息\nSELECT \n\t*\nFROM \n\temployees\nWHERE \n\tjob_id NOT IN('SH_CLERK','IT_PROG');\n#--------------------------------------\nSELECT \n\t*\nFROM \n\temployees\nWHERE \n\tNOT(job_id ='SH_CLERK' OR job_id = 'IT_PROG');\n\n\n#4、is null/is not null\n\n#案例1：查询没有奖金的员工信息\nSELECT \n\t*\nFROM \n\temployees\nWHERE \n\tcommission_pct IS NULL;\n\n#案例2：查询有奖金的员工信息\nSELECT \n\t*\nFROM \n\temployees\nWHERE \n\tcommission_pct IS NOT NULL;\n\n#----------------对比------------------------------------\n=\t\t只能判断普通的内容\nIS  NULL        只能判断NULL值\n&lt;=>             安全等于，既能判断普通内容，又能判断NULL值\n5. 3 排序查询#进阶3：排序查询\n/*\n语法：\n\tselect 查询列表\n\tfrom 表名\n\t【where 筛选条件】\n\torder by 排序列表【asc|desc】\n\n执行顺序：\n\t①from 子句\n\t②where 子句\n\t③select 子句\n\t④order by 子句\n\n特点：\n1、asc代表的升序，desc代表的是降序，如果不写默认升序\n2、order by子句中可以支持单个字段、多个字段、表达式、函数、别名\n3、order by子句一般是放在查询语句的最后面，limit子句除外\n*/\n#案例1：查询员工信息，要求工资冲高到底排序\nSELECT * FROM employees ORDER BY salary DESC;\nSELECT * FROM employees ORDER BY salary;\n\n#案例2：查询部门编号>=90的员工信息，按入职时间的先后进行排序【添加筛选条件】\nSELECT * \nFROM employees \nWHERE department_id>=90\nORDER BY hiredate ASC;\n\n#案例3：按年薪的高低显示员工的信息和年薪【按表达式排序】\nSELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪\nFROM employees\nORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;\n\n#案例4：按年薪的高低显示员工的信息和年薪【按别名排序】\nSELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪\nFROM employees\nORDER BY 年薪 DESC;\n\n#案例5：按姓名的长度显示员工的姓名和工资【按函数】\nSELECT LENGTH(last_name) 字节长度,last_name,salary\nFROM employees\nORDER BY LENGTH(last_name) DESC;\n\n#案例6：查询员工信息，要求先按工资升序，再按员工编号降序【按多个字段排序】\nSELECT * FROM employees ORDER BY salary ASC,employees_id DESC;","categories":["学习笔记"],"tags":["MySQL"]},{"title":"MySQL学习笔记_day1","url":"https://hxf233333.gitee.io/2021/02/24/MySQL学习笔记_day1/","content":"1 数据库的好处1、持久化数据到本地2、可以实现结构化查询，方便管理\n\n2 数据库相关概念1、DB：数据库，保存一组有组织的数据容器2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据3、SQL：结构化查询语言，用于和DBMS通信的语言\n\n3 数据库存储数据的特点1、将数据放到表中，表再放到库中2、一个数据库中可以有多个表，每个表都有一个名字，用来标识自己，表名具有唯一性3、表具有一些，这些特性定义了数据在表中如何存储，类似“类”的设计4、表由列组成，我们也称为字段，所有表都是由一个或者多个列组成的，每一列类似于“类”中的属性\n\n4 MySQL的安装和介绍4.1 MySQL的安装原文安装教程：安装MySQL\n4.2 MySQL服务的启动和停止方式一：计算机-&gt;右击管理-&gt;服务方式二：通过管理员身份运行        net start mysql （启动mysql服务）        net stop mysql（停止mysql服务）\n\n4.3 MySQL服务的登录和退出方式一：通过mysql自带的客户端（只限于root用户）方式二：通过windows自带的DOS命令        登录：mysql 【-h主机名 -P端口号】 -u用户名 -p密码        退出：exit; 或 Ctrl + C\n\n4.4 MySQL的常见命令1、查看当前所有的数据库show databases；2、打开指定的库use 库名；3、查看当前库的所有表show tables；4、查看其他库的所有表show tables from 库名；5、创建表create table 表名(\n\t列名 列类型，\n\t列名 列类型\n\t...\n\t)6、查看表结构desc 表名；7、查看服务器的版本方式一：登录到mysql服务端select version()；方式二：没有登录到mysql服务端mysql  --version 或者 mysql --V\n\n4.5 MySQL的语法规范1、不区分大小写，但建议关键字大写，表名、列名小写2、每条命令最好用分号结尾3、每条命令根据需要，可以进行缩进或者换行4、注释    单行注释：#注释文字    单行注释：– 注释文字    多行注释：/*  注释文字   */\n\n5 DQL语言DQL:Data Query Language  数据查询语言\n5.1 基础查询#进阶1:基础查询\n/*\n语法：\nselect 查询列表 from 表名；\n特点：\n1、查询列表可以是：表中的字段、常量值、表达式、函数\n2、查询的结果是一个虚拟的表格\n*/\n\n#选择使用的库\nUSE myemployees;\n\n#1.查询表中的单个字段\nSELECT last_name FROM employees;\n\n#2.查询表中的多个字段\nSELECT last_name,salary,email FROM employees;\n\n#3.查询表中的所有字段\nSELECT \n\t`employee_id`,\n\t`first_name`,\n\t`last_name`,\n\t`email`,\n\t`phone_number`,\n\t`job_id`,\n\t`salary`,\n\t`commission_pct`,\n\t`manager_id`,\n\t`department_id`,\n\t`hiredate`\nFROM\n\temployees; #方式一，依次枚举，''为着重号用于区分关键字\n\nSELECT * FROM employees; #方式二，使用通配符\n\t\n#4.查询常量值\nSELECT 100；\nSELECT 'john';\n\n#5.查询表达式\nSELECT 100%98;\n\n#6.查询函数\nSELECT VERSION();\n\t\n#7.起别名\n/*\n①便于理解\n②如果要查询的字段有重名的情况，使用别名区分\n*/\n#方式一：使用AS\nSELECT last_name AS 姓,first_name AS 名 FROM employees;\n#方式二：使用空格\nSELECT last_name 姓,first_name 名 FROM employees;\n#案例：查询salary，显示结果为out put\nSELECT salary AS \"out put\" FROM employees;\n\n#8.去重\n#案例 ：查询员工表中涉及到的所有部门编号\nSELECT DISTINCT department_id FROM employees;\n\t\n#9.+号的作用\n/* \nmysql中的+号只有运算符的功能\nselect 100+100; 两个操作数都为整型，则做加法运算\nselect '123'+90; 只要其中一方为字符型，试图将字符型数值转换成数值型\n\t\t  如果转转成功，则继续做加法运算\nselect 'john'+90; 如果转换失败，则将字符型数值转换成0\nselect null+10；  只要其中一方为null，则结果肯定为null\n*/\n#案例：查询员工名和姓连接成一个字段，并显示为 姓名\nSELECT CONCAT('a','b','c') AS 结果;\nSELECT\n\tCONCAT(last_name,' ',first_name) AS 姓名\nFROM\n\temployees;\n\t\n#10.补充函数\nSElECT IFNULL(字段名,表达式);","categories":["学习笔记"],"tags":["MySQL"]},{"title":"安装MySQL","url":"https://hxf233333.gitee.io/2021/02/21/安装MySQL/","content":"windows安装MySQL安装MySQL普遍采用解压缩包的方式，然后通过命令和配置来安装，这里我在window 10上安装并配置MySQL 5.6。\n1.下载MySQL压缩包所有平台的 MySQL 下载地址为：MySQL 下载 。 挑选你需要的 MySQL Community Server 版本及对应的平台。这里我选择mysql-5.6.26-winx64。\n\n2.解压并添加环境变量解压下载的压缩包，然后把解压后的文件夹迁到想要安装的目录，如：C:\\web 下面，可以重命名为 mysql-5.6.26;\n然后右击 此电脑 -&gt;属性-&gt;高级系统设置-&gt;环境变量，在系统变量里选择PATH，在其后面添加: mysql bin文件夹的路径。\n\n3.创建my.ini配置文件在C:\\web\\mysql-5.6.26路径下创建名为my.ini的配置文件，然后编辑该文件修改或添加配置；配置修改说明如下：\n[client]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n \n[mysqld]\nexplicit_defaults_for_timestamp = true\n# 设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir=C:\\web\\mysql-5.6.26\n# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错\ndatadir=C:\\web\\mysql-5.6.26\\data\n# 允许最大连接数\nmax_connections=20\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n4.安装MySQL前面的工作做好后，就可以开始命令行安装了。\n首先以管理员身份运行cmd，通过命令cd c:\\web\\mysql-5.6.26\\bin，进入bin目录；\n然后输入命令mysqld --initialize-insecure --user=mysql初始化；\n最后输入 mysqld install 回车开始安装。\n\n输入 net start mysql 回车，启动mysql服务，\n输入 net stop mysql 回车，停止mysql服务。\n5.本地连接数据库在cmd输入 mysql -u root -p ，回车，出现 Enter password:，由于刚安装，没有设置密码，直接回车 Enter 进入；输入 show databases; 命令查看默认安装数据库。\n\n6.设置root密码依次通过以下命令修改root用户名密码：\nmysql>use mysql; \nmysql>update user set password=password('your password') where user='root'; \nmysql>flush privileges;\n输入 quit 命令退出当前登录，用新的密码重新连接 mysql。\n7.远程连接数据库MySQL默认只能本机登录，如果本机使用，就可以不用设置远程登录，使用 localhost 做为主机地址登录；如果想远程登录，通过以下命令，设置允许远程登录：\nmysql>GRANT ALL PRIVILEGES ON *.* TO 'your username'@'%' IDENTIFIED BY 'your password' WITH GRANT OPTION;\n\nyour username 和 your password 改成 MySQL数据库的用户和密码\n\nMySQL 默认3306，确保 3306 端口是可用的，在要远程的电脑上安装一个 MySQL管理工具（如sqlyog），通过 Windows 系统的IP、端口， MySQL的用户名、密码远程连接数据库，管理数据库。\n","categories":["教程"],"tags":["MySQL"]},{"title":"linux基本知识图","url":"https://hxf233333.gitee.io/2020/12/26/linux基本知识图/","content":"Linux基本知识图谱\n\n\n\n","categories":["思维导图"],"tags":["Linux"]},{"title":"利用Github Page+Hexo搭建个人博客","url":"https://hxf233333.gitee.io/2020/12/26/利用Github Page+Hexo搭建个人博客/","content":"1、准备工作本地环境首先在Ubuntu 20.4 LTS系统里部署本地环境，需要安装nodejs和git工具，由于Hexo是基于Node.js的一款博客框架，相比Jekyll框架部署更快更简洁。git是一个分布式版本控制系统，用于项目的版本控制管理。\nsudo apt install nodejs # 安装nodejs\nsudo apt install git # 安装git\nsudo apt install npm #安装npm\n可在命令行输入相应的检验是否安装成功，如果安装成功会有相应的版本号。\nnodejs -v\ngit --version\nnpm -v\n\n\n本地安装Hexo如果以上环境准备好了就可以使用npm命令开始安装Hexo，也可以查看Hexo官方文档。\n在命令行输入执行以下命令：\nsudo npm install -g hexo-cli  # 安装Hexo\nsudo init myBlog  # 会在home目录下新建一个myBlog文件夹\ncd ~/myBlog\nsudo npm install  # 会在myBlog文件夹下创建所需要的文件\n新建完成后，使用tree命令查看myBlog文件夹的一级目录如下：\nhxf@hxf-virtual-machine:~/myBlog $ tree -L 1\n.\n├── _config.landscape.yml\n├── _config.yml   # 网站的配置信息，可以在此配置大部分参数\n├── db.json        \n├── node_modules\n├── package.json\n├── package-lock.json\n├── public\n├── scaffolds   \n├── source      # 资源文件夹，包含文章Markdown文件\n└── themes      # 主题文件夹\n如果以上过程没有报错，运行hexo s命令，在浏览器中输入http://localhost:4000 回车即可预览本地效果。\n2、创建github page创建一个新仓库github给用户提供了与用户相同的静态站点，相当于一个二级域名（http://用户名.github.io)，可将同名仓库映射出去。\n\n\n配置SSH key要使用git工具首先要配置SSH key，为部署本地博客到github做准备。\n首先使用git命令全局配置本地账户：\nsudo git config --global user.name \"hxf233333\"\n\nsudo git config --global user.email \"1244792997@qq.com\"\n然后开始生成SSH key\nsudo ssh-keygen -t rsa -C '1244792997@qq.com'\n按提示回车就行，通过cat ~/.ssh/id_rsa.pub可获取到SSH key。\n然后确认并添加主机到本机ssh可信列表：\nsudo ssh -T git@github.com\n最后将刚刚获取的SSH key添加到github设置SSH keys里。\n\n\n3、部署到github首先打开本地 myBlog 文件夹下的  _config.yml 配置参数，在末尾填上以下配置（注意冒号后面有一个空格）：\n\n\n然后安装一个部署插件hexo-deployer-git：\nsudo npm install hexo-deployer-git --save\n最后执行以下命令部署上传：\nsudo hexo g -d\n在浏览器访问https://用户名.github.io就可以查看博客。\n","categories":["搭建环境"],"tags":["教程"]},{"title":"Hello World","url":"https://hxf233333.gitee.io/2020/12/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","categories":[],"tags":[]}]